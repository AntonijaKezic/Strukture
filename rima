// Definicija strukture za zadatke
struct _task;
typedef struct _task* task_position;

typedef struct _task {
    char taskType[50];      // Tip zadatka (Raspoznavanje rime / Proizvodnja rime)
    char question[100];     // Pitanje
    char answer[50];        // Odgovor (DA/NE ili bodovi)
    task_position next;     // Poveznica na sljedeći zadatak
} Task;

// Funkcija za kreiranje novog zadatka
task_position CreateTask(char* taskType, char* question, char* answer) {
    task_position newTask = (task_position)malloc(sizeof(Task));
    if (!newTask) {
        printf("Greska pri alokaciji memorije!\n");
        return NULL;
    }

    strcpy(newTask->taskType, taskType);
    strcpy(newTask->question, question);
    strcpy(newTask->answer, answer);
    newTask->next = NULL;

    return newTask;
}

// Funkcija za spremanje zadataka u datoteku
void SaveTasksToFile(task_position tasks, const char* fileName) {
    FILE* file = fopen(fileName, "w");
    if (!file) {
        printf("Greska pri otvaranju datoteke!\n");
        return;
    }

    task_position currentTask = tasks;
    while (currentTask) {
        fprintf(file, "Tip zadatka: %s\n", currentTask->taskType);
        fprintf(file, "Pitanje: %s\n", currentTask->question);
        fprintf(file, "Odgovor: %s\n", currentTask->answer);
        fprintf(file, "--------------------------\n");
        currentTask = currentTask->next;
    }

    fclose(file);
    printf("Zadaci uspjesno spremljeni u datoteku: %s\n", fileName);
}

// Funkcija za unos zadataka za raspoznavanje rime
task_position InputRhymeRecognitionTasks() {
    task_position firstTask = NULL, lastTask = NULL;

    // Raspoznavanje rime (DA/NE)
    char* rhymes[7][2] = {
        {"soba - roba", "DA"},
        {"grana - brana", "DA"},
        {"šuma - vina", "NE"},
        {"crkva - mrkva", "NE"},
        {"padobran - knjižara", "NE"},
        {"gljiva - šljiva", "DA"},
        {"vodopad - sudoper", "NE"}
    };

    for (int i = 0; i < 7; i++) {
        task_position newTask = CreateTask("Raspoznavanje rime", rhymes[i][0], rhymes[i][1]);
        if (!firstTask) {
            firstTask = newTask;
            lastTask = newTask;
        } else {
            lastTask->next = newTask;
            lastTask = newTask;
        }
    }

    return firstTask;
}

// Funkcija za unos zadataka za proizvodnju rime
task_position InputRhymeProductionTasks() {
    task_position firstTask = NULL, lastTask = NULL;

    // Proizvodnja rime (zadaci)
    char* words[7] = {"most", "meta", "puška", "crv", "lonac", "trava", "guma"};

    for (int i = 0; i < 7; i++) {
        task_position newTask = CreateTask("Proizvodnja rime", words[i], "");
        if (!firstTask) {
            firstTask = newTask;
            lastTask = newTask;
        } else {
            lastTask->next = newTask;
            lastTask = newTask;
        }
    }

    return firstTask;
}

// Funkcija za unos bodova za proizvodnju rime
void InputTotalPoints(task_position tasks) {
    char totalPoints[5];
    printf("\nUnesite ukupne bodove za zadatke proizvodnje rime: ");
    scanf(" %4s", totalPoints);
    ClearBuffer();

    task_position currentTask = tasks;
    while (currentTask) {
        if (strcmp(currentTask->taskType, "Proizvodnja rime") == 0) {
            strcpy(currentTask->answer, totalPoints); // Spremi ukupne bodove za sve zadatke proizvodnje rime
        }
        currentTask = currentTask->next;
    }
}

// Funkcija za čišćenje ulaznog bafera
void ClearBuffer() {
    while (getchar() != '\n');
}

// Funkcija za provjeru točnosti odgovora
int CheckRhymeRecognitionAnswers() {
    int correctAnswers = 0;
    char userAnswer[5];

    // Raspoznavanje rime (DA/NE)
    char* rhymes[7][2] = {
        {"soba - roba", "DA"},
        {"grana - brana", "DA"},
        {"šuma - vina", "NE"},
        {"crkva - mrkva", "NE"},
        {"padobran - knjižara", "NE"},
        {"gljiva - šljiva", "DA"},
        {"vodopad - sudoper", "NE"}
    };

    for (int i = 0; i < 7; i++) {
        printf("Pitanje %d: %s\n", i+1, rhymes[i][0]);
        printf("Unesite odgovor (DA/NE): ");
        scanf(" %4s", userAnswer);
        ClearBuffer();

        if (strcmp(userAnswer, rhymes[i][1]) == 0) {
            correctAnswers++;
        }
    }

    return correctAnswers;
}

// Funkcija za ocjenu postignuća
void EvaluatePerformance(int totalPoints) {
    if (totalPoints >= 8) {
        printf("Uredan rezultat! Osvajate %d bodova.\n", totalPoints);
    } else if (totalPoints >= 6) {
        printf("Granicno postignuce! Osvajate %d bodova.\n", totalPoints);
    } else if (totalPoints >= 0) {
        printf("Loše postignuće. Pokusajte ponovo!\n");
    } else {
        printf("Nepoznat rezultat. Pokusajte ponovo!\n");
    }
}

// Glavni program
int main() {
    int rhymeRecognitionPoints = 0;
    int rhymeProductionPoints = 0;

    // Unos zadataka za raspoznavanje rime
    printf("Unos zadataka za raspoznavanje rime:\n");
    rhymeRecognitionPoints = CheckRhymeRecognitionAnswers();

    // Unos zadataka za proizvodnju rime
    task_position tasks = NULL;
    printf("\nUnos zadataka za proizvodnju rime:\n");
    task_position rhymeProductionTasks = InputRhymeProductionTasks();
    tasks = rhymeProductionTasks;

    // Unos ukupnih bodova za proizvodnju rime
    InputTotalPoints(tasks);

    // Zbrajanje bodova
    rhymeProductionPoints = atoi(tasks->answer); // Preuzimanje bodova iz proizvodnje rime
    int totalPoints = rhymeRecognitionPoints + rhymeProductionPoints;

    // Ocjena
    EvaluatePerformance(totalPoints);

    // Ponovno pokušajte ako rezultat nije uredan
    while (totalPoints < 8) {
        printf("\nPokusajte ponovo!\n");

        // Ponovno unos zadataka
        rhymeRecognitionPoints = CheckRhymeRecognitionAnswers();
        InputTotalPoints(tasks);

        // Zbrajanje bodova
        rhymeProductionPoints = atoi(tasks->answer);
        totalPoints = rhymeRecognitionPoints + rhymeProductionPoints;

        // Ocjena
        EvaluatePerformance(totalPoints);
    }

    // Spremanje zadataka u datoteku
    SaveTasksToFile(tasks, "zadaci_za_rimu.txt");

    // Oslobađanje memorije
    task_position current = tasks;
    while (current) {
        task_position temp = current;
        current = current->next;
        free(temp);
    }

    return 0;
}
